---
title: Execution Principles and Best Practices of DDL Statements
summary: Learn about how DDL statements are implemented in TiDB, the online change process, and best practices.
---

# DDLステートメントの実行原則とベストプラクティス {#execution-principles-and-best-practices-of-ddl-statements}

このドキュメントは、TiDBに関連するDDLステートメントの実行原則とベストプラクティスについての概要を提供します。原則には、DDLオーナーモジュールとオンラインDDL変更プロセスが含まれます。

## DDL実行原則 {#ddl-execution-principles}

TiDBは、オンラインおよび非同期的なアプローチを使用してDDLステートメントを実行します。これは、DDLステートメントの実行中に他のセッションのDMLステートメントがブロックされないことを意味します。つまり、アプリケーションが実行されている間にオンラインおよび非同期のDDLステートメントを使用してデータベースオブジェクトの定義を変更できます。

### DDLステートメントの種類 {#types-of-ddl-statements}

DDLステートメントがユーザーアプリケーションを実行中にブロックするかどうかに基づいて、DDLステートメントは次のタイプに分類されます。

- **オフラインDDLステートメント**：データベースがユーザーからDDLステートメントを受信すると、まず変更されるデータベースオブジェクトをロックし、その後メタデータを変更します。DDLの実行中、データベースはユーザーアプリケーションをデータの変更からブロックします。

- **オンラインDDLステートメント**：データベースでDDLステートメントが実行されると、特定の方法が使用されて、ステートメントがユーザーアプリケーションをブロックしないようにします。これにより、DDLの実行中にユーザーが変更を提出できます。この方法は、実行プロセス中に対応するデータベースオブジェクトの正確性と一貫性を確保します。

対象のDDLオブジェクトに含まれるデータを操作するかどうかに基づいて、DDLステートメントは次のタイプに分類されます。

- **論理DDLステートメント**：論理DDLステートメントは通常、オブジェクトに格納されているデータを処理せずに、データベースオブジェクトのメタデータのみを変更します。たとえば、テーブル名や列名を変更するなどです。

  TiDBでは、論理DDLステートメントは「一般的なDDL」とも呼ばれます。これらのステートメントは通常、数十ミリ秒または数秒で完了することが多いため、システムリソースをほとんど消費せず、アプリケーションのワークロードに影響を与えません。

- **物理DDLステートメント**：物理DDLステートメントは、変更されるオブジェクトのメタデータだけでなく、オブジェクトに格納されているユーザーデータも変更します。たとえば、TiDBがテーブルのインデックスを作成すると、テーブルの定義だけでなく、新しく追加されたインデックスを構築するためにフルテーブルスキャンを実行します。

  TiDBでは、物理DDLステートメントは「再構成DDL」とも呼ばれます。現在、物理DDLステートメントには`ADD INDEX`および損失のある列タイプの変更（たとえば、`INT`タイプから`CHAR`タイプに変更する）が含まれます。これらのステートメントは実行に長い時間がかかり、実行時間はテーブル内のデータ量、マシン構成、およびアプリケーションのワークロードに影響を受けます。

  物理DDLステートメントの実行は、アプリケーションのワークロードに影響を与える可能性があります。一方で、TiKVからCPUおよびI/Oリソースを消費してデータを読み取り、新しいデータを書き込みます。また、**DDLオーナーとして機能するTiDBノード**または**TiDB Distributed eXecution Framework（DXF）によってスケジュールされたTiDBノードが`ADD INDEX`タスクを実行するためにTiDBからCPUリソースを消費**します。

  > **Note:**
  >
  > 物理DDLタスクの実行は通常、ユーザーアプリケーションに最も大きな影響を与えます。したがって、この影響を最小限に抑えるための鍵は、実行中の物理DDLステートメントの設計を最適化することです。これにより、ユーザーアプリケーションへの影響を軽減できます。

### TiDB DDLモジュール {#tidb-ddl-module}

TiDB DDLモジュールは、DDLオーナー（またはオーナー）の役割を導入し、TiDBクラスタ内でのすべてのDDLステートメントの実行のプロキシとして機能します。現在の実装では、TiDBクラスタ全体で1つのTiDBノードのみが任意の時点でオーナーとして選出されます。TiDBノードがオーナーとして選出されると、そのTiDBノードで開始されたワーカーがクラスタ内のDDLタスクを処理できます。

TiDBは、etcdの選挙メカニズムを使用して、複数のTiDBノードからオーナーを選出します。デフォルトでは、各TiDBノードがオーナーに選出される可能性があります（`run-ddl`を構成して選挙へのノードの参加を管理できます）。選出されたオーナーノードには期間があり、それを更新して期間を維持します。オーナーノードがダウンした場合、etcdを介して別のノードが新しいオーナーとして選出され、クラスタ内のDDLタスクを継続できます。

DDLオーナーの簡単な説明は次のとおりです：

![DDLオーナー](/media/ddl-owner.png)

`ADMIN SHOW DDL`ステートメントを使用して現在のDDLオーナーを表示できます。"

```sql
ADMIN SHOW DDL;
```

```sql
+------------+--------------------------------------+---------------+--------------+--------------------------------------+-------+
| SCHEMA_VER | OWNER_ID                             | OWNER_ADDRESS | RUNNING_JOBS | SELF_ID                              | QUERY |
+------------+--------------------------------------+---------------+--------------+--------------------------------------+-------+
|         26 | 2d1982af-fa63-43ad-a3d5-73710683cc63 | 0.0.0.0:4000  |              | 2d1982af-fa63-43ad-a3d5-73710683cc63 |       |
+------------+--------------------------------------+---------------+--------------+--------------------------------------+-------+
1 row in set (0.00 sec)
```

### TiDBでのオンラインDDL非同期変更の動作方法 {#how-the-online-ddl-asynchronous-change-works-in-tidb}

設計の初めから、TiDBのDDLモジュールはオンライン非同期変更モードを採用しており、これによりアプリケーションを修正する際にダウンタイムを経験することなく変更できます。

DDLの変更には、通常、"変更前"の状態から"変更後"の状態に移行することが含まれます。オンラインDDL変更では、この移行は相互に互換性のある複数の小さなバージョン状態を導入することで行われます。DDLステートメントの実行中、同じクラスター内のTiDBノードは、変更オブジェクトの小さなバージョンの差が2つ以上でない限り、異なる小さなバージョンの変更を持つことができます。隣接する小さなバージョン同士が相互に互換性があるため、これが可能です。

このように、複数の小さなバージョンを経て進化することで、メタデータが複数のTiDBノード間で正しく同期されることが保証されます。これにより、プロセス中にデータを変更するユーザートランザクションの正確性と一貫性が維持されます。

例として`ADD INDEX`を取ると、状態変更の全体的なプロセスは以下のようになります：

```
absent -> delete only -> write only -> write reorg -> public
```

ユーザーにとって、新しく作成されたインデックスは`public`状態になる前は利用できません。

<SimpleTab>
<div label="TiDB v6.2.0以前のオンラインDDL非同期変更">

v6.2.0以前、TiDB SQLレイヤーで非同期スキーマ変更を処理するプロセスは次のようになります。

1. MySQLクライアントがTiDBサーバーにDDLリクエストを送信します。

2. リクエストを受信した後、TiDBサーバーはMySQLプロトコルレイヤーでリクエストを解析および最適化し、その後TiDB SQLレイヤーに実行のために送信します。

   TiDBのSQLレイヤーがDDLリクエストを受け取ると、`start job`モジュールを開始してリクエストを特定のDDLジョブ（つまりDDLタスク）にカプセル化し、その後ステートメントのタイプに基づいて対応するDDLジョブキューにこのジョブを格納します。対応するワーカーに処理が必要なジョブを通知します。

3. ジョブを処理するための通知を受け取ったら、ワーカーはDDLオーナーの役割を持っているかどうかを判断します。持っている場合、直接ジョブを処理します。そうでない場合、処理なしで終了します。

   TiDBサーバーがオーナーの役割を持っていない場合、別のノードがオーナーでなければなりません。オーナーの役割を持つノードのワーカーは、実行可能なジョブがあるか定期的にチェックします。そのようなジョブが特定された場合、ワーカーはジョブを処理します。

4. ワーカーがジョブを処理した後、ジョブをKVレイヤーのジョブキューから削除し、`job history queue`に配置します。ジョブをカプセル化した`start job`モジュールは、`job history queue`内のジョブのIDを定期的にチェックして処理されたかどうかを確認します。そうであれば、ジョブに対応する全体のDDL操作が終了します。

5. TiDBサーバーはDDL処理結果をMySQLクライアントに返します。

TiDB v6.2.0以前、DDL実行フレームワークには次の制限がありました。

- TiKVクラスターには`general job queue`と`add index job queue`の2つのキューしかありません。これらはそれぞれ論理DDLと物理DDLを処理します。
- DDLオーナーは常にDDLジョブを先入れ先出しの方法で処理します。
- DDLオーナーは同じタイプのDDLタスク（論理または物理のいずれか）を1つだけ実行できます。これは比較的厳格であり、ユーザーエクスペリエンスに影響を与えます。

これらの制限により、いくつかの「意図しない」DDLブロッキング動作が発生する可能性があります。詳細については、[SQL FAQ - DDL Execution](https://docs.pingcap.com/tidb/stable/sql-faq#ddl-execution)を参照してください。

</div>
<div label="v6.2.0以降の並列DDLフレームワーク">

TiDB v6.2.0以前、オーナーは同じタイプのDDLタスク（論理または物理のいずれか）を1つだけ実行できるため、ユーザーエクスペリエンスに影響を与えることがあります。

DDLタスク間に依存関係がない場合、並列実行はデータの正確性と一貫性に影響しません。たとえば、ユーザーAが`T1`テーブルにインデックスを追加し、ユーザーBが`T2`テーブルから列を削除する場合、これら2つのDDLステートメントは並列で実行できます。

DDL実行のユーザーエクスペリエンスを向上させるために、v6.2.0以降、TiDBはオーナーによってDDLタスクの関連性を決定することができるようになりました。そのロジックは次のとおりです。

- 同じテーブルで実行されるDDLステートメントは互いにブロックされます。
- `DROP DATABASE`およびデータベース内のすべてのオブジェクトに影響を与えるDDLステートメントは互いにブロックされます。
- 異なるテーブルでのインデックスの追加および列の型変更は同時に実行できます。
- 論理DDLステートメントは、前の論理DDLステートメントが実行されるのを待たなければなりません。
- その他の場合、利用可能な並列DDL実行のレベルに基づいてDDLを実行できます。

具体的には、TiDBはv6.2.0でDDL実行フレームワークを以下の点でアップグレードしました。

- DDLオーナーは前述のロジックに基づいてDDLタスクを並列で実行できます。
- DDLジョブキューの先入れ先出しの問題が解決されました。DDLオーナーはもはやキュー内の最初のジョブを選択するのではなく、現在の時間で実行可能なジョブを選択します。
- 物理DDLステートメントを処理するワーカーの数が増加し、複数の物理DDLステートメントを並列で実行できるようになりました。

  TiDBのすべてのDDLタスクはオンライン変更アプローチを使用して実装されているため、TiDBは新しいDDLジョブの関連性をオーナーを通じて決定し、この情報に基づいてDDLタスクをスケジュールできます。このアプローチにより、分散データベースは従来のデータベースと同じレベルのDDL並列性を実現できます。

並列DDLフレームワークはTiDBのDDLステートメントの実行能力を向上させ、商用データベースの使用パターンとの互換性を高めます。

</div>
</SimpleTab>

## ベストプラクティス {#best-practices}

### 物理DDLの実行速度とアプリケーション負荷への影響をシステム変数を通じてバランスさせる {#balance-the-physical-ddl-execution-speed-and-the-impact-on-application-load-through-system-variables}

物理DDLステートメント（インデックスの追加や列の型変更を含む）を実行する際に、以下のシステム変数の値を調整して、DDLの実行速度とアプリケーション負荷への影響をバランスさせることができます。

- [`tidb_ddl_reorg_worker_cnt`](/system-variables.md#tidb_ddl_reorg_worker_cnt): この変数はDDL操作のための再構成ワーカーの数を設定し、バックフィルの並列処理を制御します。

- [`tidb_ddl_reorg_batch_size`](/system-variables.md#tidb_ddl_reorg_batch_size): この変数は`re-organize`フェーズのDDL操作のバッチサイズを設定し、バックフィルするデータ量を制御します。

  推奨値：

  - 他の負荷がない場合、`tidb_ddl_reorg_worker_cnt`と`tidb_ddl_reorg_batch_size`の値を増やして`ADD INDEX`操作の速度を上げることができます。たとえば、これらの変数の値をそれぞれ`20`と`2048`に設定できます。
  - 他の負荷がある場合、`tidb_ddl_reorg_worker_cnt`と`tidb_ddl_reorg_batch_size`の値を減らして、他のアプリケーションへの影響を最小限に抑えることができます。たとえば、これらの変数の値をそれぞれ`4`と`256`に設定できます。

> **ヒント:**
>
> - 上記の2つの変数はDDLタスクの実行中に動的に調整でき、次のトランザクションバッチで有効になります。
> - オペレーションのタイプとアプリケーションの負荷圧力に基づいてDDL操作を実行する適切なタイミングを選択してください。たとえば、アプリケーションの負荷が低いときに`ADD INDEX`操作を実行することをお勧めします。
> - インデックスの追加には比較的長い時間がかかるため、TiDBはコマンドを送信した後、バックグラウンドでタスクを実行します。TiDBサーバーがダウンしても、実行に影響はありません。

### 複数のDDLリクエストを並列に送信して多くのテーブルを迅速に作成する {#quickly-create-many-tables-by-concurrently-sending-ddl-requests}

テーブルの作成操作には約50ミリ秒かかります。フレームワークの制限のため、テーブルの作成にかかる実際の時間は長くなることがあります。

テーブルをより速く作成するためには、最速のテーブル作成速度を実現するために複数のDDLリクエストを並列に送信することをお勧めします。DDLリクエストを直列に送信し、オーナーノードに送信しないと、テーブルの作成速度は非常に遅くなります。

### 単一の`ALTER`ステートメントで複数の変更を行う {#make-multiple-changes-in-a-single-alter-statement}

v6.2.0以降、TiDBは単一の`ALTER`ステートメントでテーブルの複数のスキーマオブジェクト（列やインデックスなど）を変更することをサポートしており、同時にステートメント全体の原子性を確保しています。そのため、単一の`ALTER`ステートメントで複数の変更を行うことをお勧めします。

### 読み書きパフォーマンスを確認する {#check-the-read-and-write-performance}

TiDBがインデックスを追加しているとき、データのバックフィルフェーズはクラスターに読み書きの圧力をかけます。`ADD INDEX`コマンドが送信され、`write reorg`フェーズが開始された後、Grafanaダッシュボードおよびアプリケーションの応答時間でTiDBとTiKVの読み書きパフォーマンスメトリクスを確認し、`ADD INDEX`操作がクラスターに影響を与えていないかどうかを確認することをお勧めします。

## DDL関連コマンド {#ddl-related-commands}

- `ADMIN SHOW DDL`: TiDBのDDL操作の状態を表示するために使用され、現在のスキーマバージョン番号、DDLオーナーのDDL IDとアドレス、実行中のDDLタスクとSQL、および現在のTiDBインスタンスのDDL IDを含みます。詳細については、[`ADMIN SHOW DDL`](/sql-statements/sql-statement-admin-show-ddl.md#admin-show-ddl)を参照してください。

- `ADMIN SHOW DDL JOBS`: クラスター環境で実行中のDDLタスクの詳細な状態を表示するために使用されます。詳細については、[`ADMIN SHOW DDL JOBS`](/sql-statements/sql-statement-admin-show-ddl.md#admin-show-ddl-jobs)を参照してください。

- `ADMIN SHOW DDL JOB QUERIES job_id [, job_id]`: `job_id`に対応するDDLタスクの元のSQLステートメントを表示するために使用されます。詳細については、[`ADMIN SHOW DDL JOB QUERIES`](/sql-statements/sql-statement-admin-show-ddl.md#admin-show-ddl-job-queries)を参照してください。

- `ADMIN CANCEL DDL JOBS job_id, [, job_id]`: 提出されたが完了していないDDLタスクをキャンセルするために使用されます。キャンセルが完了すると、DDLタスクを実行するSQLステートメントは`ERROR 8214 (HY000): Cancelled DDL job`エラーを返します。

  完了したDDLタスクがキャンセルされた場合、`RESULT`列に`DDL Job:90 not found`エラーが表示されます。これはタスクがDDL待ちキューから削除されたことを意味します。"

## よくある質問 {#common-questions}

DDL実行に関するよくある質問については、[TiDB SQL FAQ - DDL実行](https://docs.pingcap.com/tidb/stable/sql-faq)を参照してください。
