---
title: Unique Serial Number Generation
summary: Unique serial number generation solution for developers who generate their own unique IDs.
---

# ユニークシリアル番号の生成 {#unique-serial-number-generation}

このドキュメントでは、独自のユニークIDを生成する開発者を支援するためのユニークシリアル番号生成スキームを紹介します。

## 自動増分列 {#auto-increment-column}

`AUTO_INCREMENT`は、MySQLプロトコルに対応している多くのRDBMSの列属性です。 `AUTO_INCREMENT`属性を使用すると、データベースはユーザーの介入なしにこの列に値を自動的に割り当てることができます。 テーブル内のレコード数が増加するにつれて、この列の値は自動的に増分し、一意であることが保証されます。 ほとんどの場合、`AUTO_INCREMENT`列は、実際の意味を持たないプロキシ主キーとして使用されます。

`AUTO_INCREMENT`列の制限は、列が整数型である必要があり、それに割り当てられる値が整数である必要があることです。 アプリケーションが文字、数字、およびその他の文字でスライスされたシリアル番号が必要な場合、`AUTO_INCREMENT`列を介してシリアル番号で必要な自動増分番号を取得することは難しいです。

## シーケンス {#sequence}

**シーケンス**は、アプリケーションが呼び出して増分シーケンス値を生成できるデータベースオブジェクトです。 アプリケーションは、シーケンス値を柔軟に使用して、1つ以上のテーブルに値を割り当てることができます。 アプリケーションは、シーケンス値を使用して、テキストと数字の組み合わせを生成するためのより複雑な処理にも使用できます。 このアプローチは、プロキシキーにいくつかのトラッキングと分類の意味を与えます。

シーケンスは、TiDB v4.0から利用可能です。 詳細については、[シーケンスのドキュメント](/sql-statements/sql-statement-create-sequence.md#create-sequence)を参照してください。

## Snowflakeのようなソリューション {#snowflake-like-solutions}

Snowflakeは、Twitterが提案した分散ID生成ソリューションです。 いくつかの実装があり、より一般的なものはBaiduの**uid-generator**とMeituanの**leaf**です。 このセクションでは、`uid-generator`を例に挙げます。

`uid-generator`によって生成される64ビットのID構造は次のとおりです。

```
| sign | delta seconds | worker node id | sequencs |
|------|---------------|----------------|----------|
| 1bit |     28bits    | 22bits         | 13bits   |
```

- sign: 1ビットの固定長。 常に正の数であることを示すために`0`に固定されています。
- delta seconds: デフォルトで28ビット。 現在の時間を、あらかじめ設定された基準時刻（デフォルトは`2016-05-20`）に対する秒単位の増分値として表します。 28ビットで約8.7年までサポートできます。
- worker node id: デフォルトで22ビット。 マシンIDを表します。 通常、アプリケーションプロセスの開始時に集中IDジェネレータから取得されます。 一般的な集中IDジェネレータには、自動増分列とZooKeeperが含まれます。 デフォルトの割り当てポリシーは、破棄して進むことであり、プロセスは再起動時に新しいワーカーノードIDを再取得します。 22ビットで約420万の開始までサポートできます。
- sequence: デフォルトで13ビット。 秒ごとの同時実行シーケンス。 13ビットで1秒あたり8192の同時シーケンスをサポートできます。

## 数値割り当てソリューション {#number-allocation-solution}

数値割り当てソリューションは、データベースから自動増分IDを一括取得すると理解できます。 このスキームには、シーケンス番号生成テーブルが必要で、各行がシーケンスオブジェクトを表します。 テーブル定義の例は次のとおりです。

| フィールド名     | フィールドタイプ     | フィールドの説明                            |
| ---------- | ------------ | ----------------------------------- |
| `SEQ_NAME` | varchar(128) | シーケンスの名前、異なるアプリケーションを区別するために使用されます。 |
| `MAX_ID`   | bigint(20)   | 割り当てられた現在のシーケンスの最大値。                |
| `STEP`     | int(11)      | 割り当てられたセグメントの長さを示すステップ。             |

アプリケーションは、毎回構成されたステップでシーケンス番号のセグメントを取得します。 同時に、現在割り当てられたシーケンスの最大値を永続化するためにデータベースを更新します。 シーケンス番号の処理と割り当ては、アプリケーションのメモリで完了します。 シーケンス番号のセグメントが使い切られた後、アプリケーションは新しいシーケンス番号のセグメントを取得し、効果的にデータベース書き込みの圧力を軽減します。 実際には、ステップを調整してデータベースの更新頻度を制御することもできます。

最後に、上記の2つのソリューションによって生成されたIDは、TiDBテーブルの**主キー**として直接使用するには十分にランダムではないことに注意してください。 実際には、生成されたIDにビットリバースを実行して、よりランダムな新しいIDを取得できます。 たとえば、ビットリバースを実行した後、ID `00000010100101000001111010011100`は`00111001011110000010100101000000`になり、`11111111111111111111111111111101`は`10111111111111111111111111111111`になります。
