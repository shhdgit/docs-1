---
title: Unique Serial Number Generation
summary: Unique serial number generation solution for developers who generate their own unique IDs.
---

# ユニークシリアルナンバーの生成 {#unique-serial-number-generation}

このドキュメントでは、独自のユニークIDを生成する開発者を支援するためのユニークシリアルナンバーの生成スキームを紹介します。

## 自動インクリメントカラム {#auto-increment-column}

`AUTO_INCREMENT`は、MySQLプロトコルに対応した多くのRDBMSのカラム属性です。`AUTO_INCREMENT`属性を使用すると、データベースはユーザーの介入なしにこのカラムに値を自動的に割り当てることができます。テーブル内のレコード数が増加するにつれて、このカラムの値は自動的に増分し、一意であることが保証されます。ほとんどのシナリオでは、`AUTO_INCREMENT`カラムは実際の意味を持たないプロキシ主キーとして使用されます。

`AUTO_INCREMENT`カラムの制限は、カラムが整数型である必要があり、それらに割り当てられる値が整数である必要があることです。アプリケーションで必要なシリアルナンバーが文字、数字、その他の文字で区切られている場合、ユーザーは`AUTO_INCREMENT`カラムを介してシリアルナンバーで必要な自動インクリメント番号を取得することが困難です。

## シーケンス {#sequence}

**シーケンス**は、アプリケーションが呼び出して増分シーケンス値を生成できるデータベースオブジェクトです。アプリケーションは、シーケンス値を柔軟に使用して、1つ以上のテーブルに値を割り当てることができます。アプリケーションは、より複雑な処理にシーケンス値を使用して、テキストと数字の組み合わせを生成することもできます。このアプローチにより、プロキシキーにいくつかの追跡と分類の意味が与えられます。

シーケンスは、TiDB v4.0から利用可能です。詳細については、[シーケンスのドキュメント](/sql-statements/sql-statement-create-sequence.md#create-sequence)を参照してください。

## Snowflakeのようなソリューション {#snowflake-like-solutions}

Snowflakeは、Twitterが提案した分散ID生成ソリューションです。いくつかの実装があり、より人気のあるものにはBaiduの**uid-generator**とMeituanの**leaf**があります。このセクションでは、`uid-generator`を例に使用します。

`uid-generator`によって生成される64ビットのID構造は次のとおりです。

    | 符号 | デルタ秒 | ワーカーノードID | シーケンス |
    |------|---------------|----------------|----------|
    | 1ビット |     28ビット    | 22ビット         | 13ビット   |

- 符号: 1ビットの固定長。生成されたIDが常に正の数であることを示すために`0`に固定されます。
- デルタ秒: デフォルトでは28ビット。現在の時刻を表す、あらかじめ設定された基準時刻（デフォルトは`2016-05-20`）からの秒単位の増分値。28ビットで約8.7年をサポートできます。
- ワーカーノードID: デフォルトでは22ビット。マシンIDを表します。通常、アプリケーションプロセスが開始されるときに集中型IDジェネレーターから取得されます。一般的な集中型IDジェネレーターには、自動インクリメントカラムとZooKeeperがあります。デフォルトの割り当てポリシーは、捨てて進むものであり、プロセスは再起動時に新しいワーカーノードIDを再取得します。22ビットで約420万の開始をサポートできます。
- シーケンス: デフォルトでは13ビット。秒ごとの並行シーケンス。13ビットで1秒あたり8192の並行シーケンスをサポートできます。

## 数値割り当てソリューション {#number-allocation-solution}

数値割り当てソリューションは、データベースから自動インクリメントIDを一括で取得することを理解することができます。このスキームでは、シーケンス番号生成テーブルが必要で、各行がシーケンスオブジェクトを表します。テーブル定義の例は次のとおりです。

| フィールド名     | フィールドタイプ     | フィールドの説明                            |
| ---------- | ------------ | ----------------------------------- |
| `SEQ_NAME` | varchar(128) | シーケンスの名前。異なるアプリケーションを区別するために使用されます。 |
| `MAX_ID`   | bigint(20)   | 割り当てられた現在のシーケンスの最大値。                |
| `STEP`     | int(11)      | ステップ。割り当てられたセグメントの長さを示します。          |

アプリケーションは、毎回設定されたステップでシーケンス番号のセグメントを取得します。同時にデータベースを更新して、割り当てられた現在のシーケンスの最大値を永続化します。シーケンス番号の処理と割り当ては、アプリケーションのメモリで完了します。シーケンス番号のセグメントが使い切られると、アプリケーションは新しいシーケンス番号のセグメントを取得し、データベース書き込みの圧力を効果的に軽減します。実際には、ステップを調整してデータベース更新の頻度を制御することもできます。

最後に、上記の2つのソリューションで生成されたIDは、TiDBテーブルの**主キー**として直接使用するには十分にランダムではありません。実際には、生成されたIDにビットリバースを実行して、よりランダムな新しいIDを取得することができます。たとえば、ビットリバースを実行すると、ID `00000010100101000001111010011100`は`00111001011110000010100101000000`になり、`11111111111111111111111111111101`は`10111111111111111111111111111111`になります。
